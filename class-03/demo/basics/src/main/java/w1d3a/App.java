/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package w1d3a;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;

public class App {

    public static void main(String[] args) {

        testHashSet();
        testHashMap();

        testExceptions();
        testPaths();
        testReadLines();
        testReadBuffer();
        testReadBufferCorrect();

        try {
            // you don't have to catch the exception in the same function.
            // by adding "throws" you can make the caller deal with it.
            List<String> lines = getAllLines("unicorns.txt");
            System.out.println(lines);
        } catch (IOException ex) {
            ex.printStackTrace();
        }

        testOlderFileIO();
    }

    public static void testOlderFileIO() {
        // java.io is the 'older' way of accessing files
        // There are some technical/performance differences that matter at the edges
        // (but you all aren't quite ready for that :))

        // Some libraries and other parts of java will use the "File" instead of "Path"
        File file = new File("unicorns.txt");

        // Scanner works a lot like buffered reader.
        // But has slightly different options.
        // This is here just as an example.
        try (Scanner scanner = new Scanner(file)) {
            while (scanner.hasNextLine()) {
                System.out.println(scanner.nextLine());
            }
        } catch (IOException ex) {
            System.out.println("IO:" + ex);
        }
    }

    public static List<String> getAllLines(String filePath) throws IOException {
        Path path = Paths.get(filePath);
        return Files.readAllLines(path);
    }

    public static void testReadBufferCorrect() {
        Path path = Paths.get("unicorns.txt");

        try (BufferedReader reader = Files.newBufferedReader(path)) {
            String line = reader.readLine();
            while (line != null) {
                System.out.println(line);
                line = reader.readLine();
            }

            // note:  IntelliJ calls this line redundant!
            // because it's wrapped in the try () {} above
            // it will "auto close"
            reader.close();

            // if it accesses a i/o resource (files, network sockets)
            // and it has a close() method
            // then you probably want to wrap it in try () {}

        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static void testReadBuffer() {
        Path path = Paths.get("unicorns.txt");

        try {
            // instead of reading everything in at once (and using all that memory)
            // we read in the file line by line using a "buffered" reader
            BufferedReader reader = Files.newBufferedReader(path);

            // we read in the first line
            String line = reader.readLine();
            while (line != null) {
                // then only print if it's not null
                System.out.println(line);

                // then pull the next line and repeat
                line = reader.readLine();
            }

            // when you're done, you need to close your reader
            // this 'releases' the resources
            // (Ever seen a "file in use" error?)
            reader.close();

            // But what happens if there's an error?  will the reader get closed?
            // see testReadBufferCorrect

        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static void testReadLines() {
        Path path = Paths.get("unicorns.txt");

        // ArrayList is a type of List
        // so you can write it like this (more later!)
        List<String> list = new ArrayList<>();

        try {
            // we _have_ to wrap this in a try catch
            // what all could go wrong?
            List<String> lines = Files.readAllLines(path);
            System.out.println(lines.size());

        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static void testPaths() {
        // relative paths will be 'relative' to your starting location
        // for apps we're running, it's the root of your java project
        // We use Paths.get instead of new Path() due to OS differences (more later)
        Path path = Paths.get("unicorns.txt");

        // "Absolute paths" are like "c:/my/path/here/unicorns.txt"
        // or nix/osx "/my/path/here" (note the first slash at the beginning.  This indicates "root")

        // you can convert between them.
        Path absPath = path.toAbsolutePath();
        System.out.println(absPath);

        // and you can determine which you have
        System.out.println(path.isAbsolute());
        System.out.println(absPath.isAbsolute());
    }

    public static void testExceptions() {
        try {
            System.out.println(isStringLongerThan(null, 5));
        } catch (IllegalArgumentException ex) {
            System.out.println("arg");
            ex.printStackTrace();
        } catch (NullPointerException ex) {
            System.out.println("null");
            ex.printStackTrace();
        } finally {
            System.out.println("Always happens, even when there is an exception!");
        }
    }

    public static boolean isStringLongerThan(String input, int length) {
        if (input == null) {
//            throw new IllegalArgumentException("input cannot be null");
        }
        return input.length() > length;
    }

    public static void testHashMap() {
        // key/value
        HashMap<String, Integer> map = new HashMap<>();
        map.put("MyItem", 771);
        map.put("MyItem", 77652);

        System.out.println(map.size());
        System.out.println(map.get("MyItem"));

        System.out.println(map.get("WHATTTT!"));
        // int test2 = null;  // not valid
        Integer test = null;  // valid!  Because it's an object, not a primitive
        // java will convert between the two.
        // Integer just wraps an int, making it usable for <T> generics

        if (map.containsKey("MyItem")) {
            System.out.println("Has MyItem!");
        }

        // use a hashmap when you want to look up something by a key.
        // it doesn't have to be a string! (but that's the most common use case)
    }

    public static void testHashSet() {
        HashSet<Integer> set = new HashSet<>();
        set.add(5);
        set.add(6);
        set.add(6);

        // items only show up once
        System.out.println(set.size());

        // you can check if they're already there
        System.out.println(set.contains(6));
        System.out.println(set.contains(1));

        // if you need to keep track of 'Have I seen this?'
        // or you only want to ever have one copy of the item
        // then use a hashset!
    }

    public static boolean arrayContains(int[] array, int value) {
        for (int item : array) {
            if (item == value) {
                return true;
            }
        }
        return false;
    }

    public static int[] getLengths(String[] array) {
        int[] results = new int[array.length];
        for (int i = 0; i < array.length; i++) {
            results[i] = array[i].length();
        }
        return results;
    }
}
