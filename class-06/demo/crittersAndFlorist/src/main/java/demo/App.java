/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package demo;

// imports all the classes in florist

import florist.*;
// by importing this directly
// florist.Rose will be used instead of demo.Rose when you do new Rose();
import florist.Rose;

import critters.BadCritterException;
import critters.Critter;
// we never had to import Cat or Robot to use it!

import java.nio.file.Path;
import java.nio.file.Paths;

public class App {

    public static void main(String[] args) {

        // Depending on the operating system
        // "Path" will be a different concrete type
        // (Check the debugger and hover over it to see what the type is!)
        Path paths = Paths.get("resources/whatever.txt");


        // Testing out our critter parser
        // Also see the tests!
        String critterType = "BAD DOG";
        try {
            Critter myCritter = Critter.parse(critterType);
            outputNoise(myCritter);
        } catch (BadCritterException ex) {
            ex.printStackTrace();
        }


    }

    public static void outputNoise(Critter critter) {
        System.out.println(critter.makeNoise());
    }

    public static void flowersDemo() {
//         we can't instantiate a flower because it's abstract!
//                Flower flower = new Flower(
//                "Borgon the Great",
//                "Orange");

        testWalkThrough();

        // you can assign Tulip to Flower because Tulip extends Flower
        Flower tulip = new Tulip("Tilly the Indomitable");

        // Tulip is a flower, so you can pass it to sunshine
        sunshine(tulip);

        // It's declared a Flower, so can't access Tulip properties
        // tulip.bulbSize

        Rose rose = new Rose();

        // even though rose is not declared as a Flower
        // it is still a type of Flower, and will pass to sunshine
        sunshine(rose);

        // it's declared a Rose, so can access properties
        System.out.println(rose.numThorns);

        // the rose toString() method is overriden
        System.out.println(rose.toString());

        // in case of name conflict there will be a compiler error
        // you can fix it by using the longer name with the package
        demo.Rose titanicRose = new demo.Rose();
        florist.Rose otherRose = new florist.Rose();
    }

    public static void testWalkThrough() {
        Rose rose = new Rose();

        // increases height and thorns, but doesn't bloom
        rose.grow();

        // increases height and thorns, but doesn't bloom
        rose.grow();

        // increases height and thorns, and blooms!
        rose.grow();
    }

    public static void sunshine(Flower flower) {
        // since the function only takes Flower
        // only flower properties and methods are available

        flower.grow();
        System.out.println(flower.name);
        System.out.println(flower.color);
        System.out.println(flower.getHeight());
        System.out.println(flower.getBloomHeight());

        // this will throw a Cast exception if the flower is not of type rose
        // but if _is_ of type rose, it will work
//        ((Rose) flower).numThorns = 99;
    }

}
