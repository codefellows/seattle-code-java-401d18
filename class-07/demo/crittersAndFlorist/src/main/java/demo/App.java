/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package demo;

import collections.Collection;
//import collections.Node;
import critters.*;
import flower.Daisy;
import flower.Flower;
import flower.Rose;

import java.util.ArrayList;
import java.util.List;

public class App {

    public static void main(String[] args) {
        // Reworking yesterday's abstract as an interface
//        testCritters();

        // implementing a more realistic example of interfaces
//        testInterfaces();

        // some basic use of <Generics>
//        testGenerics();

        // Recap of abstract classes, methods, public/private/protected
//        testReview();
    }

    public static void testReview() {

        Daisy f = new Daisy();

        // because we declared as a daisy
        // we can call daisy method
        f.beADaisy();

        // but it's also a flower, so sunshine works!
        sunshine(f);
        sunshine(f);
        sunshine(f);

        // doesn't compile because the default constructor doesn't exist
//        Rose rose = new Rose();

        Rose tallRose = new Rose(55);
        sunshine(tallRose);
        tallRose.beARose();

        // doSomethingNeato is a private method, so this won't compile!
//        rose.doSomethingNeato();

        // flower setBloomed is a protected method
        // so it's only available within the package.
        // this won't compile!
//        f.setBloomed(true);

        // we were silly and our rose is also a logger!
        tallRose.log("Hello!");

        boolean amIReallyBloomed = f.isBloomed();
    }

    public static void sunshine(Flower flower) {
        // flowers can grow!
        flower.grow();

        // but doesn't know anything about daisies or roses
//        flower.beARose();
//        flower.beADaisy();

        // this will fail when rose is passed in
        // java "trusts" that you know what you're doing
        // because a flower _might_ be a daisy.
//        Daisy daisy = (Daisy) flower;
    }

    public static void testGenerics() {

        // We've seen generics already
        // A List<> can contain all types of things
        List<String> list = new ArrayList<>();
        list.add("AHHHH");

        // this won't compile because the list doesn't except Integers
//        list.add(5);

        // a generic method will retain the type from the passed in type
        int x = test(5);
        double y = test(6.0);

        // while a method written as "Object" will not.
        // instead it has to be Cast (which is dangerous - it could fail at runtime!)
        int z = (int) anotherTest(5);
        String zz = (String) anotherTest("ahhhhhhhh");

        // Nodes are protected - we're hiding the implementation
        // but:  If they weren't protected, the "type" <> will be inferred based on usage!
//        Node<String> node = new Node<>("Hi");
//        Node<Integer> nodeInt = new Node<>(5);

        // Generics can be a class, allowing it to store all types of critters
        Collection<Critter> coll = new Collection<>();

        // like cats
        Cat cat = new Cat("CatNameHere");
        coll.add(cat);

        // or robots
        Robot robot = new Robot("Robob");
//        Node<Critter> robotNode = new Node<>(robot);

        coll.add(robot);
//        coll.head.next = robotNode;
    }

    public static Object anotherTest(Object myValue) {
        // object in - object out
        System.out.println(myValue);
        return myValue;
    }

    public static <TValue extends Number> TValue test(TValue myValue) {
        // TValue in - TValue out.
        // TValue must be a "Number"
        // Integer, Double, Long, etc. are all Number
        // Go to declaration to see what all a Number must implement
        System.out.println(myValue);
        return myValue;
    }

    public static void testInterfaces() {
        // We've created a class to handle output to the console
        ConsoleLogger console = new ConsoleLogger();
        console.log("This is a message");

        // our service will output "Loud" NoiseMakers (all upper case)
        // and we pass it in our class to output
        NoiseMakerOutputService service = new NoiseMakerOutputService(console);

        // Robot and Cats are both noisemakers
        Robot robot = new Robot("Robox");
        Cat cat = new Cat("kat");

        // so both will output
        service.output(robot);
        service.output(cat);
    }

    public static void testCritters() {
        // Our basic robot
        Robot robot = new Robot("Rob");
        robot.reboot();

        // it implements NoiseMaker and Dancer
        // so it can do both of these things
        String noise = robot.makeNoise();
        String dance = robot.getDance();

        // But our cat only implements makeNoise
        Cat cat = new Cat("The Cat.");

        // Just like class inheritance, you can assign them to matching things
        Dancer dancer = robot;
        NoiseMaker noiseMaker = robot;

        // Cat's can't dance, silly.
//        Dancer dancingCat = cat;
        NoiseMaker noiseyCat = cat;

        // our makeNoise function takes any NoiseMaker
        makeNoise(robot);
        makeNoise(cat);

        // We refactored our Critter class to just have names
        // and outputName can handle any critter
        outputName(robot);
        outputName(cat);
    }

    public static void makeNoise(NoiseMaker noiseMaker) {
        String noise = noiseMaker.makeNoise();
    }

    public static void doDance(Dancer dancer) {
        dancer.getBetterDance();
    }

    public static void outputName(Critter critter) {
        System.out.println(critter.getName());
    }
}
