/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package demo;

import com.google.gson.Gson;

import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.lang.reflect.Method;

public class App {

    public static void main(String[] args) {
        testGsonBasic();
        testGsonObjects();
        testReflection();
    }

    /**
     * Just throws an exception for testing!
     *
     * @throws Exception
     */
    public static void makesAMess() throws Exception {
        throw new Exception("AHHHHHHH!");

        // this is a compile error because it can never happen.
        // when an exception is "thrown" it will immediately exit
        // similar to a return;
//        System.out.println("Did I make it here?");
    }


    public static void testGsonBasic() {

        // to do something with GSON we import at the top:
        // import com.google.gson.Gson;
        // and then create a new one!
        Gson gson = new Gson();

        // results in a string "5"
        String x = gson.toJson(5);


        int[] values = new int[]{1, 5, 6};
        // results in a string "[1,5,6]"
        String z = gson.toJson(values);


        // Parses the "2" string to an int 2
        // note int.class is how you tell gson
        // what to create from the json String.

        // the .class isn't necessary to output to string
        int results2 = gson.fromJson("2", int.class);

        // same as before, except an array!
        // in json, anything that looks like [] is an array
        // and {} is an object (a Java Class)
        String json = "[1, 5, 9]";
        // note the int[].class to make this work
        int[] results = gson.fromJson(json, int[].class);


    }

    public static void testGsonObjects() {
        Gson gson = new Gson();

        // Quotes in strings have to be escaped like: \"
        // IntelliJ does this for us just by copy/pasting.

        // Our basic json object
        String jsonMore = "{ \"name\": \"Bob\", \"age\": 5, \"favoriteThings\": [\"Candy\", \"World Domination\"] }";


        // we can create a person from it the same as basic things
        // just by passing in Person.class (note the upper case Person)
        Person resultingPerson = gson.fromJson(jsonMore, Person.class);

        // JSON doesn't know anything about our app, though!
        // So it will map to critter with similar properties just the same
        Critter critter = gson.fromJson(jsonMore, Critter.class);

        // you can get an array of Person just by passing Person[].class (the same as int[].class)
        String jsonPeople = "[{ \"name\": \"Bob\", \"age\": 5, \"favoriteThings\": [\"Candy\", \"World Domination\"] }, { \"name\" : \"Saul\" }]";
        Person[] people = gson.fromJson(jsonPeople, Person[].class);

        // GSON can also handle embedded objects
        // the "pet" property is an object {}
        // so it has to be represented as a class in Java
        // so the Person object has a pet property that models the shape of a pet
        String petJson = "{ \"name\": \"Bob\", \"age\": 5, \"favoriteThings\": [\"Candy\", \"World Domination\"], \"pet\": { \"name\": \"Rock\" } }";
        Person myperson = gson.fromJson(petJson, Person.class);


        // The important part to remember is that the class properties have to match the names in the json
        // "name": "Bob" will map to: public String name; in java.
        // "pet": {} will map to public Pet pet;
        // "pet": {} could also map to Public Person pet;  <= as long as the name matches!
    }


    /**
     * How magic works in GSON/Spring
     * <p>
     * You don't need to know this, but it's fun!
     */
    public static void testReflection() {
        Critter critter = new Critter();
        critter.name = "Sally";

        // a @Deprecated function
        critter.sayHi();


        // the "Class" contains information describing a class
        Class c = Critter.class;

        // like all the fields
        Field[] fields = c.getFields();

        try {
            // you can ues that field instance
            // to get a field value out of an instance

            // in this case: field[0] is about the name
            // by using the get(critter), it'll return the value of
            // the name field of critter
            Object o = fields[0].get(critter);

            // It returns an object, there is no type safety when you're using reflection
            // so we have to know ahead of time what "type" it is (it's a String)
            System.out.println(o);

        } catch (IllegalAccessException e) {

            // it's also really easy to mess this up!
            // it's like using casts times a thousand
            e.printStackTrace();
        }

        // you can get methods
        Method[] methods = c.getMethods();

        // and the @Annotations above them
        // this is how IntelliJ knows about things like deprecated
        Annotation[] annots = methods[0].getAnnotations();
    }
}
